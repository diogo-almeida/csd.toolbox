length(electrodes.not.found)
theta                <- theta[idx.elec.found]  phi                  <- phi[idx.elec.found]  correct.user.labels  <- electrode.labels[idx.elec.found]
equal("F10", "F10")
any("F10", "F10")
strcmp("F10", "F10")
identical("F10", "F10")
unlist(sapply(toupper(user.labels), function(x) {identical(x, toupper(electrodes.found))}))
reorder.vector      <- unlist(sapply(toupper(user.labels), function(x) {which(x %in% toupper(electrodes.found))}))
reorder.vector
toupper(userl.labels)[1]
toupper(user.labels)[1]
toupper(user.labels)[1] %in% toupper(electrodes.found)
which(toupper(user.labels)[1] %in% toupper(electrodes.found))
toupper(electrodes.found)[1] %in% toupper(user.labels)
toupper(electrodes.found)[1] == toupper(user.labels)
which(toupper(electrodes.found)[1] == toupper(user.labels))
unlist(sapply(toupper(user.labels), function(x) {which(toupper(electrodes.found)[1] == toupper(user.labels))}))
unlist(sapply(toupper(electrodes.found), function(x) {which(toupper(x) == toupper(user.labels))}))
reorder.vector      <- unlist(sapply(toupper(electrodes.found), function(x) {which(toupper(x) == toupper(user.labels))}))  electrodes.found    <- electrodes.found[reorder.vector]  theta               <- theta[reorder.vector]  phi                 <- phi[reorder.vector]
electrodes.found
unlist(sapply(toupper(user.labels), function(x) {which(toupper(x) == toupper(electrodes.found))}))
electrodes.found
electrode.labels  <- as.vector(montage.lookup.table$ElectrodeLabel)  theta <- montage.lookup.table$Theta  phi   <- montage.lookup.table$Phi  # Find the indices of the user labels found in the look up table as well as  # the indices (in user.labels) of the electrodes that might not have been   # found.  idx.elec.found     <- toupper(electrode.labels) %in% toupper(user.labels)  idx.elec.not.found <- !(toupper(user.labels) %in% toupper(electrode.labels))  # Get the labels of the electrodes supplied by the user from the look up table  electrodes.found      <- electrode.labels[idx.elec.found]  electrodes.not.found  <- user.labels[idx.elec.not.found]  theta                <- theta[idx.elec.found]  phi                  <- phi[idx.elec.found]  correct.user.labels  <- electrode.labels[idx.elec.found]
unlist(sapply(toupper(user.labels), function(x) {which(toupper(x) == toupper(electrodes.found))}))
E
electrodes.found
electrode.labels  <- as.vector(montage.lookup.table$ElectrodeLabel)  theta <- montage.lookup.table$Theta  phi   <- montage.lookup.table$Phi  # Find the indices of the user labels found in the look up table as well as  # the indices (in user.labels) of the electrodes that might not have been   # found.  idx.elec.found     <- toupper(electrode.labels) %in% toupper(user.labels)  idx.elec.not.found <- !(toupper(user.labels) %in% toupper(electrode.labels))  # Get the labels of the electrodes supplied by the user from the look up table  electrodes.found      <- electrode.labels[idx.elec.found]  electrodes.not.found  <- user.labels[idx.elec.not.found]  theta                <- theta[idx.elec.found]  phi                  <- phi[idx.elec.found]  correct.user.labels  <- electrode.labels[idx.elec.found]
unlist(sapply(toupper(electrodes.found), function(x) {which(toupper(x) == toupper(user.labels))}))
reorder.vector      <- unlist(sapply(toupper(electrodes.found), function(x) {which(toupper(x) == toupper(user.labels))}))  electrodes.found    <- electrodes.found[reorder.vector]  theta               <- theta[reorder.vector]  phi                 <- phi[reorder.vector]
re
electrodes.found
reorder.vector
reorder.vector[1]
E
typeof(reorder.vector)
Get the look up table for electrode names and their Theta and Phi locations  electrode.labels  <- as.vector(montage.lookup.table$ElectrodeLabel)  theta <- montage.lookup.table$Theta  phi   <- montage.lookup.table$Phi  # Find the indices of the user labels found in the look up table as well as  # the indices (in user.labels) of the electrodes that might not have been   # found.  idx.elec.found     <- toupper(electrode.labels) %in% toupper(user.labels)  idx.elec.not.found <- !(toupper(user.labels) %in% toupper(electrode.labels))  # Get the labels of the electrodes supplied by the user from the look up table  electrodes.found      <- electrode.labels[idx.elec.found]  electrodes.not.found  <- user.labels[idx.elec.not.found]  theta                <- theta[idx.elec.found]  phi                  <- phi[idx.elec.found]  correct.user.labels  <- electrode.labels[idx.elec.found]
electrodes.found
reorder.vector      <- unlist(sapply(toupper(electrodes.found), function(x) {which(toupper(x) == toupper(user.labels))}))
reorder.vector
electrodes.found[reorder.vector]
electrodes.found[reorder.vector[1]]
reorder.vector[1]
length(reorder.vector)
electrodes.found[electrodes.found[reorder.vector]]
electrodes.found[user.labels[reorder.vector]]
as.integer(reorder.vector)
electrodes.found[as.integer(reorder.vector)]
electrodes.found[reorder.vector[1]]
reorder.vector[1]
electrodes.found[31]
electrodes.found
E
electrodes.found
order(reorder.vector)
electrodes.found[order(reorder.vector)]
reorder.vector      <- order(unlist(sapply(toupper(electrodes.found),     function(x) {which(toupper(x) == toupper(user.labels))}))  )  electrodes.found    <- electrodes.found[reorder.vector]  theta               <- theta[reorder.vector]  phi                 <- phi[reorder.vector]  idx.user.labels.found <- which(toupper(user.labels) %in% electrodes.found)  correct.user.labels <- electrode.labels[idx.elec.found]
electrodes.found
theta
rm(list = ls())
=============================# CSD Toolbox Tutorial - R port# =============================## ExampleCode2.R# --------------# R port of the MatLab code that supplements the CSD Toolbox online tutorial# (URL: "http://psychophysiology.cpmc.columbia.edu/CSDtoolbox.htm")## Updated: $Date: 2009/05/20 19:34:00 $ $Author: jk $# Updated: November 2, 2013 by da# ------------ Step 0 -----------------------------------------------------# Set the relevant paths!# ~~~~~~~~~~~~~~~~~~~~~~~path.toolbox <- "/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox"toolbox.filename <- "CSDToolbox_v1.1.R"path.montage <- "CSDtoolbox1.1/resource"montage.filename <- "10-5-System_Mastoids_EGI129.csd"path.example <- "CSDtoolbox1.1/exam"example.montage <- "E31.asc"example.data <- "NR_C66_trr.dat"# Load the toolboxsource(file.path(path.toolbox, toolbox.filename))# ------------ Step 1 -----------------------------------------------------# understand the spherical coordinate system of the CSD toolbox# ---------
--- Step 2 -----------------------------------------------------E <- scan(file.path(path.toolbox, path.example, example.montage), what = "character")bad.E <- c(E, "MR45")# Solving the issue with the fact that the Electrode List in the example file is# all in caps (e.g., CZ, FZ, etc.), but the montage database has the standard # upper and lower case electrode names like Cz, Fz, etc.tmp.montage <- read.delim(file.path(path.toolbox, path.montage,   montage.filename), header = F, sep = "", skip = 2)montage.colnames <- c("ElectrodeLabel", "Theta", "Phi", "Radius", "X", "Y", "Z",  "OffSphereSurface")colnames(tmp.montage) <- montage.colnames# Create the montage look up tabledefault.montage.lookup.table <- tmp.montageExtractMontage <- function(user.labels,                           montage.lookup.table = default.montage.lookup.table,                            verbose = T) {  # is electrode.labels a list?  if (is.list(user.labels) == T) {    user.labels <- as.vector(unlist(user.labels))    c
at("Converting electrode labels from list to vector format... DONE!\n\n")  }  # Get the look up table for electrode names and their Theta and Phi locations  electrode.labels  <- as.vector(montage.lookup.table$ElectrodeLabel)  theta <- montage.lookup.table$Theta  phi   <- montage.lookup.table$Phi  # Find the indices of the user labels found in the look up table as well as  # the indices (in user.labels) of the electrodes that might not have been   # found.  idx.elec.found     <- toupper(electrode.labels) %in% toupper(user.labels)  idx.elec.not.found <- !(toupper(user.labels) %in% toupper(electrode.labels))  # Get the labels of the electrodes supplied by the user from the look up table  electrodes.found      <- electrode.labels[idx.elec.found]  electrodes.not.found  <- user.labels[idx.elec.not.found]  theta                <- theta[idx.elec.found]  phi                  <- phi[idx.elec.found]  correct.user.labels  <- electrode.labels[idx.elec.found]  reorder.vector      <- order(unlist(sap
ply(toupper(electrodes.found),     function(x) {which(toupper(x) == toupper(user.labels))}))  )  electrodes.found    <- electrodes.found[reorder.vector]  theta               <- theta[reorder.vector]  phi                 <- phi[reorder.vector]  idx.user.labels.found <- which(toupper(user.labels) %in% electrodes.found)  correct.user.labels <- electrode.labels[idx.elec.found]#
  phiT         <- 90 - phi                    # calculate phi from top of sphere  theta2       <- (2 * pi * theta) / 360      # convert degrees to radians  phi2         <- (2 * pi * phiT) / 360  xycoord      <- pol2cart(theta2, phi2)      # get plane coordinates  xy           <- cbind(xycoord$x, xycoord$y)  colnames(xy) <- c("x", "y")  xy           <- xy / max(xy, na.rm = T)     # set maximum to unit length  xy           <- xy / 2 + 0.5                # adjust to range 0-1  if (length(user.labels) != length(electrodes.found)){    cat("\n=========================================\n",        "ATTENTION:\n",        "Only", length(correct.user.labels), "out of", length(user.labels),        "EEG channel labels you provided were identified!\n",        "The following channels were not found in the look up table:\n",        electrodes.not.found,       "\n=========================================\n"    )    extracted.montage <- list(electrode.labels = electrodes.found, theta = theta,       phi = p
hi, xy = xy, not.found = electrodes.not.found    )  } else {    extracted.montage <- list(electrode.labels = electrodes.found, theta = theta,       phi = phi, xy = xy, not.found = NA    )  }  return(extracted.montage)}# done. Ready to keep going.#
M <- ExtractMontage(user.labels = E)#MapMontage(M);# R Note: I haven't ported MapMontage.m to R yet.# However, it is relatively easy to plot M using standard R:plot(M$xy, type = "n", xlim = c(-0.2, 1.2), ylim = c(-0.2, 1.2), asp = 1)text(M$xy, M$electrode.labels)symbols(   M$xy[which(M$electrode.labels == "Cz"), 1],   M$xy[which(M$electrode.labels == "Cz"), 2],   circles = 0.6,   inches = F,   add = T)# ------------ Step 3 -----------------------------------------------------GetGH <- function(M, m = 4) {  require(orthopolynom)#
  possible.m.values <- 2:10  if (!(m %in% possible.m.values)) {    stop(      sprintf("Invalid m = %d (use 2, 3, 4, ..., 10)", m)    )  }  ThetaRad <- (2 * pi * M$theta) / 360  # convert Theta and Phi to radians ... ### Does not match Malab!! This is because order of electrodes changes in the ExtractMontage function!  PhiRad   <- (2 * pi * M$phi) / 360    # ... and Cartesian coordinates ...  XYZ <- sph2cart(ThetaRad, PhiRad, 1)  # ... for optimal resolution  X   <- XYZ$x  Y   <- XYZ$y  Z   <- XYZ$z  nElec <- length(M$electrode.labels)   # determine size of EEG montage  # initialize interelectrode matrix...  EF <- array(numeric(nElec * nElec), dim = c(nElec, nElec))  # ...and compute all cosine distances  for (i in 1:nElec) {    for (j in 1:nElec) {      EF[i, j] <- 1 - (((X[i] - X[j])^2 + (Y[i] - Y[j])^2 + (Z[i] - Z[j])^2 ) / 2) ## Does not match Matlab!    }  }  cat(sprintf("Spline flexibility:  m = %d\n", m))  N <- 50  # set N iterations  G <- array(numeric(nElec * nElec), dim = c
(nElec,nElec)) # claim memory for   H <- array(numeric(nElec * nElec), dim = c(nElec,nElec)) # G- and H-matrices  # intialize progress bar  cat(sprintf("%d iterations for %d sites [", N, nElec))   for (i in 1:nElec) {    for (j in 1:nElec) {      # compute Legendre polynomial      # R Note (2009-11-14): this requires the R package "orthopolynom"      #                      this part of the code changed quite a bit from the      #                      original Matlab code.      p.coefs <- legendre.polynomials(N, normalized = F)      p <- as.numeric(polynomial.values(p.coefs, EF[i, j]))      P <- p[2:(N + 1)]      g = 0          # Initialize g and h in order to      h = 0          # compute h- and g-functions      if (j == 1) {        cat('*')     # show progress      }                for (n in 1:N) {        g = g + ((( 2 * n + 1) * P[n]) / ((n * n + n)^m    ))        h = h + (((-2 * n - 1) * P[n]) / ((n * n + n)^(m-1)))      }        G[i, j] =  g / 4 / pi  # finalize cell of G-matrix
H[i, j] = -h / 4 / pi  # finalize cell of H-matrix      }   }   cat("]\n")                  # finalize progress bar   GH <- list(G = G, H = H)   return(GH)}system.time(  GH <- GetGH(M))G <- GH$G  # This does not match the output from Matlab!!!!H <- GH$H# ------------ Step 4 -----------------------------------------------------D <- read.delim(file.path(path.toolbox, path.example, example.data), sep = "", header = F)D <- t(D)#matplot(D, type = "l", col = "black", lty = 1)# ------------ Step 5 -----------------------------------------------------CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 1*(10^-5),                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim
(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- eeg.data                    # claim memory for output matrices  X <- Y  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ] )/ head.parameter  # ... and scale to head size    }    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ] )      }    }  }  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}system.time(  Interpolation
<- CalculateCSD(D, G, H))X <- Interpolation$csdX <- t(X)matplot(X, type = "l", col = "black", lty = 1)
matplot(X[, c(14,24)], type = "l", col = c("blue", "green"), lty = 1)
D <- t(D)matplot(D, type = "l", col = "black", lty = 1)
matplot(D[, c(14,24)], type = "l", col = c("blue", "green"), lty = 1)
ExtractMontage(bad.E)
M.bad <- ExtractMontage(bad.E)
M.bad$electrode.labels
D <- read.delim(file.path(path.toolbox, path.example, example.data), sep = "", header = F)
rm(list=ls())
ls()
set paths, import the datapath.toolbox <- "/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox"toolbox.filename <- "CSDToolbox_v1.1.R"path.montage <- "CSDtoolbox1.1/resource"montage.filename <- "10-5-System_Mastoids_EGI129.csd"path.example <- "CSDtoolbox1.1/exam"example.montage <- "E31.asc"example.data <- "NR_C66_trr.dat"# Creating the datasets## default.montage.lookup.tabledefault.montage.lookup.table <- read.delim(file.path(path.toolbox, path.montage,   montage.filename), header = F, sep = "", skip = 2)montage.colnames <- c("ElectrodeLabel", "Theta", "Phi", "Radius", "X", "Y", "Z",  "OffSphereSurface")colnames(default.montage.lookup.table) <- montage.colnames
default.montage.lookup.table
E <- scan(file.path(path.toolbox, path.example, example.montage), what = "character")D <- read.delim(file.path(path.toolbox, path.example, example.data), sep = "", header = F)
E
typeof(E)
typeof(D)
unlist(D)
head(D)
colnames(D) <- E
head(D)
as.matrix(D)
NR.C66.trr <- as.matrix(D)
NR.C66.trr
t(NR.C66.trr)
path.to.package <- "/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox"csd.data.filename <- "csd_example.RData"save(default.montage.lookup.table, NR.C66.trr, file = file.path(path.to.package, csd.data.filename))
source.path <- "/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox/R"data.path <- "/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox/data"
dir(source.path)
dir(data.path)
lapply(dir(source.path), function(x) {source(file.path(source.path, x))})
ls()
CalculateCSD
lapply(dir(data.path), function(x) {source(file.path(data.path, x))})
lapply(dir(data.path), function(x) {load(file.path(data.path, x))})
ls()
NR.C66.trr
dir(data.path)
load(file.path(data.path, "NR.C66.trr.rda"))
ls()
load(file.path(data.path, "default.montage.lookup.table.rda"))
ls()
m.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))gh.example <- GetGH(m.example) # G and H are identical in MATLAB. Problem must be in csd transformation.csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G)
csd.data$csd
csd.data$csd[,1]
round(csd.data$csd[,1], 4)
gh.example$G
gh.example$G[1,]
round(gh.example$G[1,], 4)
as.matrix(round(gh.example$G[1,], 4))
eeg.data <- t(NR.C66.trr)
eeg.data
head.parameter <- 1
lambda <- 10^-5
lambda
1*lambda
nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]
nElec
nPnts
Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }
G <- gh.example$G
H <- gh.example$H
Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }
mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- eeg.data                    # claim memory for output matrices  X <- Y  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]
mu
Z
for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }
G[1,]
round(G[1,])
round(G[1,], 4)
round(G[15,], 4)
Gi <- solve(G)
round(Gi[1,], 4)
Gi[1,]
round(Gi[1,])
round(Gi[1,])/10^-4
round(Gi[1,])/(10^-4)
round(Gi[1,])*(10^-4)
round(Gi[18,])*(10^-4)
for i = 1:size(Gi,1);                  % compute sums for each row  TC(i) = sum(Gi(i,:));end;
TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total
sgi
for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ] )/ head.parameter  # ... and scale to head size    }    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ] )      }    }  }
scalp.potentials = TRUE
for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ] )/ head.parameter  # ... and scale to head size    }    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ] )      }    }  }
for p = 1:nPnts#
  Cp = Gi * Z(:,p);                    % compute preliminary C vector#
  c0 = sum(Cp) / sgi;                  % common constant across electrodes#
  C = Cp - (c0 * TC');                 % compute final C vector#
  for e = 1:nElec;                     % compute all CSDs ...#
    X(e,p) = sum(C .* H(e,:)') / head; % ... and scale to head size#
  end;#
  if nargout > 1; for e = 1:nElec;     % if requested ...#
    Y(e,p) = c0 + sum(C .* G(e,:)');   % ... compute all SPs#
  end; end;#
end;
rm(list = ls())
source.path <- "/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox/R"data.path   <- "/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox/data"lapply(dir(source.path), function(x) {source(file.path(source.path, x))})
load(file.path(data.path, dir(data.path)[1])
)
load(file.path(data.path, dir(data.path)[2]))
m.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))gh.example <- GetGH(m.example) # G and H are identical in MATLAB. Problem must be in csd transformation.
eeg.data <- t(NR.C66.trr)G <- gh.example$GH <- gh.example$Hscalp.potentials <- TRUE
nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- eeg.data                    # claim memory for output matrices  X <- Y  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total
lambda = 1*(10^-5)
eeg.data <- t(NR.C66.trr)G <- gh.example$GH <- gh.example$Hscalp.potentials <- TRUElambda <- 10^-5head.parameter <- 1
nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- eeg.data                    # claim memory for output matrices  X <- Y  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total
sgi
scalp.potentials = FALSE
for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ] )/ head.parameter  # ... and scale to head size    }    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ] )      }    }  }
round(X[, 1], 4)
as.matrix(round(X[, 1], 4))
as.matrix(round(X[, 15], 4))
as.matrix(round(X[, 31], 4))
H[1, ]
' @title Calculates the Current Source Density estimates of EEG/ERP data.#' #' @description Calculates the Current Source Density (CSD) estimates of #'   EEG/ERP data by means of the spherical spline interpolation algorithm#'   developed by Perrin et al (1989, 1990).#'#' @param eeg.data Matrix containing the data to be transformed.#'#' @param G The transformation matrix for the interpolation of the surface #'   potentials, as calculated by function \code{\link{GetGH}}.#'#' @param H The transformation matrix for the calculation of the Current Source #'   Density (CSD) estimates, as calculated by function \code{\link{GetGH}}.#'#' @param head.parameter Head radius. Defaults to 1 for unit sphere [µV/m²]).#'   Specify a value (in cm) to rescale CSD data to smaller units [µV/cm²]#'   (e.g., use 10.0 to scale to more realistic head size).#'#' @param lambda Smoothing constant lambda for the spherical spline #'   interpolation.#'#' @param scalp.potentials Logical value. \code{TRUE} determines the the #'   spherical spline surface potential interpolation on top of the calculation #'   of the CSD estimates. \code{FALSE} makes the function return only the CSD #'   estimates. Defaults to \code{TRUE}.#'#' @return List containing the spherical spline interpolation of the CSD and #'   surface potential data.#'#' \describe{#' #' \item{csd}{Matrix containing the CSD transformed data.}#' #' \item{surface.potential}{Matrix containing the interpolation of the surface #'   potential data.}#'#' }#'#' @export#'#' @seealso \code{\link{GetGH}};#'#' @examples#' #' # From the original MATLAB CSD Toolbox tutorial#' m.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))#' gh.example <- GetGH(m.example)#' csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G, #'   H = gh.example$G#' )#' #' # Should reproduce Figures 16 of the original MATLAB CSD TOOLBOX tutorial:#' # http://psychophysiology.cpmc.columbia.edu/software/CSDtoolbox/tutorial.html#' matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", #'   ylim = c(-20, 40)#' )#'#' # Should reproduce Figures 17 of the original MATLAB CSD TOOLBOX tutorial#' matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 17", ylim = c(-10, 35)#'  )#' #' # Should reproduce Figures 18 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr, type = "l", lty = 1, main = "Figure 18", #'   ylim = c(-10, 20)#' )#' #' # Should reproduce Figures 19 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 19", ylim = c(-10, 20)#' )CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 1*(10^-5),                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- eeg.data                    # claim memory for output matrices  X <- Y  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
rm(list = ls())
ls()
source.path <- "/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox/R"data.path   <- "/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox/data"lapply(dir(source.path), function(x) {source(file.path(source.path, x))})#lapply(dir(data.path), function(x) {load(file.path(data.path, x))}) # that does not seem to work...load(file.path(data.path, dir(data.path)[1]))load(file.path(data.path, dir(data.path)[2]))# debugm.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))gh.example <- GetGH(m.example) # G and H are identical in MATLAB. Problem must be in csd transformation.
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G)
csd.data$csd
round(csd.data$csd, 4)
round(csd.data$csd[, 2000], 4)
round(csd.data$csd[, 200], 4)
as.matrix(round(csd.data$csd[, 200], 4))
as.matrix(round(csd.data$csd[, 100], 4))
for line by line comparison with matlabeeg.data <- t(NR.C66.trr)G <- gh.example$GH <- gh.example$Hscalp.potentials <- TRUElambda <- 10^-5head.parameter <- 1
nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- eeg.data                    # claim memory for output matrices  X <- Y  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }
X
round(X[,100], 4)
' @title Calculates the Current Source Density estimates of EEG/ERP data.#' #' @description Calculates the Current Source Density (CSD) estimates of #'   EEG/ERP data by means of the spherical spline interpolation algorithm#'   developed by Perrin et al (1989, 1990).#'#' @param eeg.data Matrix containing the data to be transformed.#'#' @param G The transformation matrix for the interpolation of the surface #'   potentials, as calculated by function \code{\link{GetGH}}.#'#' @param H The transformation matrix for the calculation of the Current Source #'   Density (CSD) estimates, as calculated by function \code{\link{GetGH}}.#'#' @param head.parameter Head radius. Defaults to 1 for unit sphere [µV/m²]).#'   Specify a value (in cm) to rescale CSD data to smaller units [µV/cm²]#'   (e.g., use 10.0 to scale to more realistic head size).#'#' @param lambda Smoothing constant lambda for the spherical spline #'   interpolation.#'#' @param scalp.potentials Logical value. \code{TRUE} determines the the #'   spherical spline surface potential interpolation on top of the calculation #'   of the CSD estimates. \code{FALSE} makes the function return only the CSD #'   estimates. Defaults to \code{TRUE}.#'#' @return List containing the spherical spline interpolation of the CSD and #'   surface potential data.#'#' \describe{#' #' \item{csd}{Matrix containing the CSD transformed data.}#' #' \item{surface.potential}{Matrix containing the interpolation of the surface #'   potential data.}#'#' }#'#' @export#'#' @seealso \code{\link{GetGH}};#'#' @examples#' #' # From the original MATLAB CSD Toolbox tutorial#' m.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))#' gh.example <- GetGH(m.example)#' csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G, #'   H = gh.example$G#' )#' #' # Should reproduce Figures 16 of the original MATLAB CSD TOOLBOX tutorial:#' # http://psychophysiology.cpmc.columbia.edu/software/CSDtoolbox/tutorial.html#' matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", #'   ylim = c(-20, 40)#' )#'#' # Should reproduce Figures 17 of the original MATLAB CSD TOOLBOX tutorial#' matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 17", ylim = c(-10, 35)#'  )#' #' # Should reproduce Figures 18 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr, type = "l", lty = 1, main = "Figure 18", #'   ylim = c(-10, 20)#' )#' #' # Should reproduce Figures 19 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 19", ylim = c(-10, 20)#' )CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 10^-5,                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- eeg.data                    # claim memory for output matrices  X <- Y  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G)
round(csd.data$csd[, 200], 4)
round(X[, 200], 4)
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G, lambda = 10^5, head.parameter = 1)
round(csd.data$csd[, 200], 4)
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G, lambda = 10^-5, head.parameter = 1)
round(csd.data$csd[, 200], 4)
CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 10^-5,                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G, lambda = 10^-5, head.parameter = 1)
round(csd.data$csd[, 200], 4)
round(X[, 200], 4)
eeg.data <- t(NR.C66.trr)G <- gh.example$GH <- gh.example$Hscalp.potentials <- TRUElambda <- 10^-5head.parameter <- 1
nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total
sgi
X
for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }
X
' @title Calculates the Current Source Density estimates of EEG/ERP data.#' #' @description Calculates the Current Source Density (CSD) estimates of #'   EEG/ERP data by means of the spherical spline interpolation algorithm#'   developed by Perrin et al (1989, 1990).#'#' @param eeg.data Matrix containing the data to be transformed.#'#' @param G The transformation matrix for the interpolation of the surface #'   potentials, as calculated by function \code{\link{GetGH}}.#'#' @param H The transformation matrix for the calculation of the Current Source #'   Density (CSD) estimates, as calculated by function \code{\link{GetGH}}.#'#' @param head.parameter Head radius. Defaults to 1 for unit sphere [µV/m²]).#'   Specify a value (in cm) to rescale CSD data to smaller units [µV/cm²]#'   (e.g., use 10.0 to scale to more realistic head size).#'#' @param lambda Smoothing constant lambda for the spherical spline #'   interpolation.#'#' @param scalp.potentials Logical value. \code{TRUE} determines the the #'   spherical spline surface potential interpolation on top of the calculation #'   of the CSD estimates. \code{FALSE} makes the function return only the CSD #'   estimates. Defaults to \code{TRUE}.#'#' @return List containing the spherical spline interpolation of the CSD and #'   surface potential data.#'#' \describe{#' #' \item{csd}{Matrix containing the CSD transformed data.}#' #' \item{surface.potential}{Matrix containing the interpolation of the surface #'   potential data.}#'#' }#'#' @export#'#' @seealso \code{\link{GetGH}};#'#' @examples#' #' # From the original MATLAB CSD Toolbox tutorial#' m.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))#' gh.example <- GetGH(m.example)#' csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G, #'   H = gh.example$G#' )#' #' # Should reproduce Figures 16 of the original MATLAB CSD TOOLBOX tutorial:#' # http://psychophysiology.cpmc.columbia.edu/software/CSDtoolbox/tutorial.html#' matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", #'   ylim = c(-20, 40)#' )#'#' # Should reproduce Figures 17 of the original MATLAB CSD TOOLBOX tutorial#' matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 17", ylim = c(-10, 35)#'  )#' #' # Should reproduce Figures 18 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr, type = "l", lty = 1, main = "Figure 18", #'   ylim = c(-10, 20)#' )#' #' # Should reproduce Figures 19 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 19", ylim = c(-10, 20)#' )CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 10^-5,                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  print(X)  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  print(X)  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G, lambda = 10^-5, head.parameter = 1)
CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 10^-5,                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  #print(X)  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    print(C)    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  #print(X)  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G, lambda = 10^-5, head.parameter = 1)
% CSD - Current Source Density (CSD) transformation based on spherical spline%       surface Laplacian as suggested by Perrin et al. (1989, 1990)%% (published in appendix of Kayser J, Tenke CE, Clin Neurophysiol 2006;117(2):348-368)%% Usage: [X, Y] = CSD(Data, G, H, lambda, head);%% Implementation of algorithms described by Perrin, Pernier, Bertrand, and% Echallier in Electroenceph Clin Neurophysiol 1989;72(2):184-187, and % Corrigenda EEG 02274 in Electroenceph Clin Neurophysiol 1990;76:565.% % Input parameters:%   Data = surface potential electrodes-by-samples matrix%      G = g-function electrodes-by-electrodes matrix%      H = h-function electrodes-by-electrodes matrix% lambda = smoothing constant lambda (default = 1.0e-5)%   head = head radius (default = no value for unit sphere [µV/m≤])%          specify a value [cm] to rescale CSD data to smaller units [µV/cm≤]%          (e.g., use 10.0 to scale to more realistic head size)%% Output parameter:%      X = current source density (CSD) transform electrodes-by-samples matrix%      Y = spherical spline surface potential (SP) interpolation electrodes-%          by-samples matrix (only if requested)%% Copyright (C) 2003 by J¸rgen Kayser (Email: kayserj@pi.cpmc.columbia.edu)% GNU General Public License (http://www.gnu.org/licenses/gpl.txt)% Updated: $Date: 2005/02/11 14:00:00 $ $Author: jk $%        - code compression and comments % Updated: $Date: 2007/02/07 11:30:00 $ $Author: jk $%        - recommented rescaling (unit sphere [µV/m≤] to realistic head size [µV/cm≤])%   Fixed: $Date: 2009/05/16 11:55:00 $ $Author: jk $%        - memory claim for output matrices used inappropriate G and H dimensions%   Added: $Date: 2009/05/21 10:52:00 $ $Author: jk $%        - error checking of input matrix dimensions%function [X, Y] = CSD(Data, G, H, lambda, head)[nElec,nPnts] = size(Data);            % get data matrix dimensionsif ~(size(G,1) == size(G,2)) | ...     % matrix dimension error checking:    ~(size(H,1) == size(H,2)) | ...     % G and H matrix must be nElec-by-nElec   ~(size(G,1) == nElec) | ...            ~(size(H,1) == nElec)   X = NaN; Y = NaN;                   % default to invalid output    help CSD   disp(sprintf(strcat('*** Error: G (%d-by-%d) and H (%d-by-%d) matrix', ...                       ' dimensions must match rows (%d) of data matrix'), ...                       size(G),size(H),nElec));   return end   mu = mean(Data);                       % get grand meanZ = (Data - repmat(mu,nElec,1));       % compute average referenceY = Data;  X = Y;                      % claim memory for output matricesif nargin < 5; head = 1.0; end;        % initialize scaling variable [µV/m≤]head = head * head;                    % or rescale data to head sphere [µV/cm≤]if nargin < 4; lambda = 1.0e-5; end;   % initialize smoothing constantfor e = 1:size(G,1);                   % add smoothing constant to diagonale  G(e,e) = G(e,e) + lambda; end; Gi = inv(G);                           % compute G inversefor i = 1:size(Gi,1);                  % compute sums for each row  TC(i) = sum(Gi(i,:));end;sgi = sum(TC);                         % compute sum totalfor p = 1:nPnts  Cp = Gi * Z(:,p);                    % compute preliminary C vector  c0 = sum(Cp) / sgi;                  % common constant across electrodes  C = Cp - (c0 * TC');                 % compute final C vector  print(C)  for e = 1:nElec;                     % compute all CSDs ...    X(e,p) = sum(C .* H(e,:)') / head; % ... and scale to head size  end;  if nargout > 1; for e = 1:nElec;     % if requested ...    Y(e,p) = c0 + sum(C .* G(e,:)');   % ... compute all SPs  end; end;end;
CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 10^-5,                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  #print(X)  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    print(C)    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  #print(X)  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G, lambda = 10^-5, head.parameter = 1)
' @title Calculates the Current Source Density estimates of EEG/ERP data.#' #' @description Calculates the Current Source Density (CSD) estimates of #'   EEG/ERP data by means of the spherical spline interpolation algorithm#'   developed by Perrin et al (1989, 1990).#'#' @param eeg.data Matrix containing the data to be transformed.#'#' @param G The transformation matrix for the interpolation of the surface #'   potentials, as calculated by function \code{\link{GetGH}}.#'#' @param H The transformation matrix for the calculation of the Current Source #'   Density (CSD) estimates, as calculated by function \code{\link{GetGH}}.#'#' @param head.parameter Head radius. Defaults to 1 for unit sphere [µV/m²]).#'   Specify a value (in cm) to rescale CSD data to smaller units [µV/cm²]#'   (e.g., use 10.0 to scale to more realistic head size).#'#' @param lambda Smoothing constant lambda for the spherical spline #'   interpolation.#'#' @param scalp.potentials Logical value. \code{TRUE} determines the the #'   spherical spline surface potential interpolation on top of the calculation #'   of the CSD estimates. \code{FALSE} makes the function return only the CSD #'   estimates. Defaults to \code{TRUE}.#'#' @return List containing the spherical spline interpolation of the CSD and #'   surface potential data.#'#' \describe{#' #' \item{csd}{Matrix containing the CSD transformed data.}#' #' \item{surface.potential}{Matrix containing the interpolation of the surface #'   potential data.}#'#' }#'#' @export#'#' @seealso \code{\link{GetGH}};#'#' @examples#' #' # From the original MATLAB CSD Toolbox tutorial#' m.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))#' gh.example <- GetGH(m.example)#' csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G, #'   H = gh.example$G#' )#' #' # Should reproduce Figures 16 of the original MATLAB CSD TOOLBOX tutorial:#' # http://psychophysiology.cpmc.columbia.edu/software/CSDtoolbox/tutorial.html#' matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", #'   ylim = c(-20, 40)#' )#'#' # Should reproduce Figures 17 of the original MATLAB CSD TOOLBOX tutorial#' matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 17", ylim = c(-10, 35)#'  )#' #' # Should reproduce Figures 18 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr, type = "l", lty = 1, main = "Figure 18", #'   ylim = c(-10, 20)#' )#' #' # Should reproduce Figures 19 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 19", ylim = c(-10, 20)#' )CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 10^-5,                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  #print(X)  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    #print(C) #until here the outputs are the same!    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    print(X[e, p])    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  #print(X)  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G, lambda = 10^-5, head.parameter = 1)
' @title Calculates the Current Source Density estimates of EEG/ERP data.#' #' @description Calculates the Current Source Density (CSD) estimates of #'   EEG/ERP data by means of the spherical spline interpolation algorithm#'   developed by Perrin et al (1989, 1990).#'#' @param eeg.data Matrix containing the data to be transformed.#'#' @param G The transformation matrix for the interpolation of the surface #'   potentials, as calculated by function \code{\link{GetGH}}.#'#' @param H The transformation matrix for the calculation of the Current Source #'   Density (CSD) estimates, as calculated by function \code{\link{GetGH}}.#'#' @param head.parameter Head radius. Defaults to 1 for unit sphere [µV/m²]).#'   Specify a value (in cm) to rescale CSD data to smaller units [µV/cm²]#'   (e.g., use 10.0 to scale to more realistic head size).#'#' @param lambda Smoothing constant lambda for the spherical spline #'   interpolation.#'#' @param scalp.potentials Logical value. \code{TRUE} determines the the #'   spherical spline surface potential interpolation on top of the calculation #'   of the CSD estimates. \code{FALSE} makes the function return only the CSD #'   estimates. Defaults to \code{TRUE}.#'#' @return List containing the spherical spline interpolation of the CSD and #'   surface potential data.#'#' \describe{#' #' \item{csd}{Matrix containing the CSD transformed data.}#' #' \item{surface.potential}{Matrix containing the interpolation of the surface #'   potential data.}#'#' }#'#' @export#'#' @seealso \code{\link{GetGH}};#'#' @examples#' #' # From the original MATLAB CSD Toolbox tutorial#' m.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))#' gh.example <- GetGH(m.example)#' csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G, #'   H = gh.example$G#' )#' #' # Should reproduce Figures 16 of the original MATLAB CSD TOOLBOX tutorial:#' # http://psychophysiology.cpmc.columbia.edu/software/CSDtoolbox/tutorial.html#' matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", #'   ylim = c(-20, 40)#' )#'#' # Should reproduce Figures 17 of the original MATLAB CSD TOOLBOX tutorial#' matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 17", ylim = c(-10, 35)#'  )#' #' # Should reproduce Figures 18 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr, type = "l", lty = 1, main = "Figure 18", #'   ylim = c(-10, 20)#' )#' #' # Should reproduce Figures 19 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 19", ylim = c(-10, 20)#' )CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 10^-5,                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  #print(X)  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    #print(C) #until here the outputs are the same!    for (e in 1:nElec) {       # compute all CSDs ...      print(sum(C * H[e, ]) / head.parameter)      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    #print(X[e, p]) # at this point, this have been fucked up!    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  #print(X)  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G, lambda = 10^-5, head.parameter = 1)
nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  #print(X)  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total
sgi
for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    #print(C) #until here the outputs are the same!    for (e in 1:nElec) {       # compute all CSDs ...      #print(sum(C * H[e, ]) / head.parameter)      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    #print(X[e, p]) # at this point, this have been fucked up!    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }
X
X
X
csd.data$csd
X
' @title Calculates the Current Source Density estimates of EEG/ERP data.#' #' @description Calculates the Current Source Density (CSD) estimates of #'   EEG/ERP data by means of the spherical spline interpolation algorithm#'   developed by Perrin et al (1989, 1990).#'#' @param eeg.data Matrix containing the data to be transformed.#'#' @param G The transformation matrix for the interpolation of the surface #'   potentials, as calculated by function \code{\link{GetGH}}.#'#' @param H The transformation matrix for the calculation of the Current Source #'   Density (CSD) estimates, as calculated by function \code{\link{GetGH}}.#'#' @param head.parameter Head radius. Defaults to 1 for unit sphere [µV/m²]).#'   Specify a value (in cm) to rescale CSD data to smaller units [µV/cm²]#'   (e.g., use 10.0 to scale to more realistic head size).#'#' @param lambda Smoothing constant lambda for the spherical spline #'   interpolation.#'#' @param scalp.potentials Logical value. \code{TRUE} determines the the #'   spherical spline surface potential interpolation on top of the calculation #'   of the CSD estimates. \code{FALSE} makes the function return only the CSD #'   estimates. Defaults to \code{TRUE}.#'#' @return List containing the spherical spline interpolation of the CSD and #'   surface potential data.#'#' \describe{#' #' \item{csd}{Matrix containing the CSD transformed data.}#' #' \item{surface.potential}{Matrix containing the interpolation of the surface #'   potential data.}#'#' }#'#' @export#'#' @seealso \code{\link{GetGH}};#'#' @examples#' #' # From the original MATLAB CSD Toolbox tutorial#' m.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))#' gh.example <- GetGH(m.example)#' csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G, #'   H = gh.example$G#' )#' #' # Should reproduce Figures 16 of the original MATLAB CSD TOOLBOX tutorial:#' # http://psychophysiology.cpmc.columbia.edu/software/CSDtoolbox/tutorial.html#' matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", #'   ylim = c(-20, 40)#' )#'#' # Should reproduce Figures 17 of the original MATLAB CSD TOOLBOX tutorial#' matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 17", ylim = c(-10, 35)#'  )#' #' # Should reproduce Figures 18 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr, type = "l", lty = 1, main = "Figure 18", #'   ylim = c(-10, 20)#' )#' #' # Should reproduce Figures 19 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 19", ylim = c(-10, 20)#' )CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 10^-5,                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  #print(X)  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    #print(C) #until here the outputs are the same!    for (e in 1:nElec) {       # compute all CSDs ...      #print(sum(C * H[e, ]) / head.parameter)      print(H[e])      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    #print(X[e, p]) # at this point, this have been fucked up!    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  #print(X)  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G, lambda = 10^-5, head.parameter = 1)
' @title Calculates the Current Source Density estimates of EEG/ERP data.#' #' @description Calculates the Current Source Density (CSD) estimates of #'   EEG/ERP data by means of the spherical spline interpolation algorithm#'   developed by Perrin et al (1989, 1990).#'#' @param eeg.data Matrix containing the data to be transformed.#'#' @param G The transformation matrix for the interpolation of the surface #'   potentials, as calculated by function \code{\link{GetGH}}.#'#' @param H The transformation matrix for the calculation of the Current Source #'   Density (CSD) estimates, as calculated by function \code{\link{GetGH}}.#'#' @param head.parameter Head radius. Defaults to 1 for unit sphere [µV/m²]).#'   Specify a value (in cm) to rescale CSD data to smaller units [µV/cm²]#'   (e.g., use 10.0 to scale to more realistic head size).#'#' @param lambda Smoothing constant lambda for the spherical spline #'   interpolation.#'#' @param scalp.potentials Logical value. \code{TRUE} determines the the #'   spherical spline surface potential interpolation on top of the calculation #'   of the CSD estimates. \code{FALSE} makes the function return only the CSD #'   estimates. Defaults to \code{TRUE}.#'#' @return List containing the spherical spline interpolation of the CSD and #'   surface potential data.#'#' \describe{#' #' \item{csd}{Matrix containing the CSD transformed data.}#' #' \item{surface.potential}{Matrix containing the interpolation of the surface #'   potential data.}#'#' }#'#' @export#'#' @seealso \code{\link{GetGH}};#'#' @examples#' #' # From the original MATLAB CSD Toolbox tutorial#' m.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))#' gh.example <- GetGH(m.example)#' csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G, #'   H = gh.example$G#' )#' #' # Should reproduce Figures 16 of the original MATLAB CSD TOOLBOX tutorial:#' # http://psychophysiology.cpmc.columbia.edu/software/CSDtoolbox/tutorial.html#' matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", #'   ylim = c(-20, 40)#' )#'#' # Should reproduce Figures 17 of the original MATLAB CSD TOOLBOX tutorial#' matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 17", ylim = c(-10, 35)#'  )#' #' # Should reproduce Figures 18 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr, type = "l", lty = 1, main = "Figure 18", #'   ylim = c(-10, 20)#' )#' #' # Should reproduce Figures 19 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 19", ylim = c(-10, 20)#' )CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 10^-5,                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  #print(X)  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    #print(C) #until here the outputs are the same!    for (e in 1:nElec) {       # compute all CSDs ...      #print(sum(C * H[e, ]) / head.parameter)      print(H[e, ])      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    #print(X[e, p]) # at this point, this have been fucked up!    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  #print(X)  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G, lambda = 10^-5, head.parameter = 1)
H(1,)
H[1, ]
round(H[1, ], 4)
round(H[31, ], 4)
' @title Calculates the Current Source Density estimates of EEG/ERP data.#' #' @description Calculates the Current Source Density (CSD) estimates of #'   EEG/ERP data by means of the spherical spline interpolation algorithm#'   developed by Perrin et al (1989, 1990).#'#' @param eeg.data Matrix containing the data to be transformed.#'#' @param G The transformation matrix for the interpolation of the surface #'   potentials, as calculated by function \code{\link{GetGH}}.#'#' @param H The transformation matrix for the calculation of the Current Source #'   Density (CSD) estimates, as calculated by function \code{\link{GetGH}}.#'#' @param head.parameter Head radius. Defaults to 1 for unit sphere [µV/m²]).#'   Specify a value (in cm) to rescale CSD data to smaller units [µV/cm²]#'   (e.g., use 10.0 to scale to more realistic head size).#'#' @param lambda Smoothing constant lambda for the spherical spline #'   interpolation.#'#' @param scalp.potentials Logical value. \code{TRUE} determines the the #'   spherical spline surface potential interpolation on top of the calculation #'   of the CSD estimates. \code{FALSE} makes the function return only the CSD #'   estimates. Defaults to \code{TRUE}.#'#' @return List containing the spherical spline interpolation of the CSD and #'   surface potential data.#'#' \describe{#' #' \item{csd}{Matrix containing the CSD transformed data.}#' #' \item{surface.potential}{Matrix containing the interpolation of the surface #'   potential data.}#'#' }#'#' @export#'#' @seealso \code{\link{GetGH}};#'#' @examples#' #' # From the original MATLAB CSD Toolbox tutorial#' m.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))#' gh.example <- GetGH(m.example)#' csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G, #'   H = gh.example$G#' )#' #' # Should reproduce Figures 16 of the original MATLAB CSD TOOLBOX tutorial:#' # http://psychophysiology.cpmc.columbia.edu/software/CSDtoolbox/tutorial.html#' matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", #'   ylim = c(-20, 40)#' )#'#' # Should reproduce Figures 17 of the original MATLAB CSD TOOLBOX tutorial#' matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 17", ylim = c(-10, 35)#'  )#' #' # Should reproduce Figures 18 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr, type = "l", lty = 1, main = "Figure 18", #'   ylim = c(-10, 20)#' )#' #' # Should reproduce Figures 19 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 19", ylim = c(-10, 20)#' )CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 10^-5,                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  #print(X)  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    #print(C) #until here the outputs are the same!    for (e in 1:nElec) {       # compute all CSDs ...      #print(sum(C * H[e, ]) / head.parameter)      #print(H[e, ])      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size      print(sum(C * H[e, ]) / head.parameter)    }    #print(X[e, p]) # at this point, this have been fucked up!    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  #print(X)  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G, lambda = 10^-5, head.parameter = 1)
' @title Calculates the Current Source Density estimates of EEG/ERP data.#' #' @description Calculates the Current Source Density (CSD) estimates of #'   EEG/ERP data by means of the spherical spline interpolation algorithm#'   developed by Perrin et al (1989, 1990).#'#' @param eeg.data Matrix containing the data to be transformed.#'#' @param G The transformation matrix for the interpolation of the surface #'   potentials, as calculated by function \code{\link{GetGH}}.#'#' @param H The transformation matrix for the calculation of the Current Source #'   Density (CSD) estimates, as calculated by function \code{\link{GetGH}}.#'#' @param head.parameter Head radius. Defaults to 1 for unit sphere [µV/m²]).#'   Specify a value (in cm) to rescale CSD data to smaller units [µV/cm²]#'   (e.g., use 10.0 to scale to more realistic head size).#'#' @param lambda Smoothing constant lambda for the spherical spline #'   interpolation.#'#' @param scalp.potentials Logical value. \code{TRUE} determines the the #'   spherical spline surface potential interpolation on top of the calculation #'   of the CSD estimates. \code{FALSE} makes the function return only the CSD #'   estimates. Defaults to \code{TRUE}.#'#' @return List containing the spherical spline interpolation of the CSD and #'   surface potential data.#'#' \describe{#' #' \item{csd}{Matrix containing the CSD transformed data.}#' #' \item{surface.potential}{Matrix containing the interpolation of the surface #'   potential data.}#'#' }#'#' @export#'#' @seealso \code{\link{GetGH}};#'#' @examples#' #' # From the original MATLAB CSD Toolbox tutorial#' m.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))#' gh.example <- GetGH(m.example)#' csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G, #'   H = gh.example$G#' )#' #' # Should reproduce Figures 16 of the original MATLAB CSD TOOLBOX tutorial:#' # http://psychophysiology.cpmc.columbia.edu/software/CSDtoolbox/tutorial.html#' matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", #'   ylim = c(-20, 40)#' )#'#' # Should reproduce Figures 17 of the original MATLAB CSD TOOLBOX tutorial#' matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 17", ylim = c(-10, 35)#'  )#' #' # Should reproduce Figures 18 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr, type = "l", lty = 1, main = "Figure 18", #'   ylim = c(-10, 20)#' )#' #' # Should reproduce Figures 19 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 19", ylim = c(-10, 20)#' )CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 10^-5,                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  #print(X)  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    #print(C) #until here the outputs are the same!    for (e in 1:nElec) {       # compute all CSDs ...      print(H[e, ]) # This is the most bizarre thing. The matrix H is identical, but here it gives me different values!!!      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size      print(sum(C * H[e, ]) / head.parameter)    }    #print(X[e, p]) # at this point, this have been fucked up!    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  #print(X)  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$G, lambda = 10^-5, head.parameter = 1)
H
for (e in 1:nElec){print(H[e,])}
' @title Calculates the Current Source Density estimates of EEG/ERP data.#' #' @description Calculates the Current Source Density (CSD) estimates of #'   EEG/ERP data by means of the spherical spline interpolation algorithm#'   developed by Perrin et al (1989, 1990).#'#' @param eeg.data Matrix containing the data to be transformed.#'#' @param G The transformation matrix for the interpolation of the surface #'   potentials, as calculated by function \code{\link{GetGH}}.#'#' @param H The transformation matrix for the calculation of the Current Source #'   Density (CSD) estimates, as calculated by function \code{\link{GetGH}}.#'#' @param head.parameter Head radius. Defaults to 1 for unit sphere [µV/m²]).#'   Specify a value (in cm) to rescale CSD data to smaller units [µV/cm²]#'   (e.g., use 10.0 to scale to more realistic head size).#'#' @param lambda Smoothing constant lambda for the spherical spline #'   interpolation.#'#' @param scalp.potentials Logical value. \code{TRUE} determines the the #'   spherical spline surface potential interpolation on top of the calculation #'   of the CSD estimates. \code{FALSE} makes the function return only the CSD #'   estimates. Defaults to \code{TRUE}.#'#' @return List containing the spherical spline interpolation of the CSD and #'   surface potential data.#'#' \describe{#' #' \item{csd}{Matrix containing the CSD transformed data.}#' #' \item{surface.potential}{Matrix containing the interpolation of the surface #'   potential data.}#'#' }#'#' @export#'#' @seealso \code{\link{GetGH}};#'#' @examples#' #' # From the original MATLAB CSD Toolbox tutorial#' m.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))#' gh.example <- GetGH(m.example)#' csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G, #'   H = gh.example$G#' )#' #' # Should reproduce Figures 16 of the original MATLAB CSD TOOLBOX tutorial:#' # http://psychophysiology.cpmc.columbia.edu/software/CSDtoolbox/tutorial.html#' matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", #'   ylim = c(-20, 40)#' )#'#' # Should reproduce Figures 17 of the original MATLAB CSD TOOLBOX tutorial#' matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 17", ylim = c(-10, 35)#'  )#' #' # Should reproduce Figures 18 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr, type = "l", lty = 1, main = "Figure 18", #'   ylim = c(-10, 20)#' )#' #' # Should reproduce Figures 19 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 19", ylim = c(-10, 20)#' )CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 10^-5,                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  #print(X)  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    #print(C) #until here the outputs are the same!    for (e in 1:nElec) {       # compute all CSDs ...      print(H[e, ]) # This is the most bizarre thing. The matrix H is identical, but here it gives me different values!!!      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size      print(sum(C * H[e, ]) / head.parameter)    }    #print(X[e, p]) # at this point, this have been fucked up!    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  #print(X)  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$H, lambda = 10^-5, head.parameter = 1)
' @title Calculates the Current Source Density estimates of EEG/ERP data.#' #' @description Calculates the Current Source Density (CSD) estimates of #'   EEG/ERP data by means of the spherical spline interpolation algorithm#'   developed by Perrin et al (1989, 1990).#'#' @param eeg.data Matrix containing the data to be transformed.#'#' @param G The transformation matrix for the interpolation of the surface #'   potentials, as calculated by function \code{\link{GetGH}}.#'#' @param H The transformation matrix for the calculation of the Current Source #'   Density (CSD) estimates, as calculated by function \code{\link{GetGH}}.#'#' @param head.parameter Head radius. Defaults to 1 for unit sphere [µV/m²]).#'   Specify a value (in cm) to rescale CSD data to smaller units [µV/cm²]#'   (e.g., use 10.0 to scale to more realistic head size).#'#' @param lambda Smoothing constant lambda for the spherical spline #'   interpolation.#'#' @param scalp.potentials Logical value. \code{TRUE} determines the the #'   spherical spline surface potential interpolation on top of the calculation #'   of the CSD estimates. \code{FALSE} makes the function return only the CSD #'   estimates. Defaults to \code{TRUE}.#'#' @return List containing the spherical spline interpolation of the CSD and #'   surface potential data.#'#' \describe{#' #' \item{csd}{Matrix containing the CSD transformed data.}#' #' \item{surface.potential}{Matrix containing the interpolation of the surface #'   potential data.}#'#' }#'#' @export#'#' @seealso \code{\link{GetGH}};#'#' @examples#' #' # From the original MATLAB CSD Toolbox tutorial#' m.example  <- ExtractMontage(user.labels = colnames(NR.C66.trr))#' gh.example <- GetGH(m.example)#' csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G, #'   H = gh.example$G#' )#' #' # Should reproduce Figures 16 of the original MATLAB CSD TOOLBOX tutorial:#' # http://psychophysiology.cpmc.columbia.edu/software/CSDtoolbox/tutorial.html#' matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", #'   ylim = c(-20, 40)#' )#'#' # Should reproduce Figures 17 of the original MATLAB CSD TOOLBOX tutorial#' matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 17", ylim = c(-10, 35)#'  )#' #' # Should reproduce Figures 18 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr, type = "l", lty = 1, main = "Figure 18", #'   ylim = c(-10, 20)#' )#' #' # Should reproduce Figures 19 of the original MATLAB CSD TOOLBOX tutorial#' matplot(NR.C66.trr[, c(14,24)], type = "l", col = c("blue", "green"), #'   lty = 1, main = "Figure 19", ylim = c(-10, 20)#' )CalculateCSD <- function(eeg.data, G, H, head.parameter = 1, lambda = 10^-5,                         scalp.potentials = TRUE) {  nElec <- dim(eeg.data)[1]  # get data matrix dimensions  nPnts <- dim(eeg.data)[2]  # Error checking of input matrix dimensions  if (     (dim(G)[1] != dim(G)[2]) |   # matrix dimension error checking    (dim(H)[1] != dim(H)[2]) |   # G and H matrix must be nElec-by-nElec    (dim(G)[1] != nElec) |     (dim(H)[1] != nElec)) {      stop(        sprintf(          "G (%d-by-%d) and H (%d-by-%d) matrix, dimensions must match rows (%d) of data matrix",           dim(G)[1], dim(G)[2], dim(H)[1], dim(H)[2], nElec        )      )   }  mu <- colMeans(eeg.data)         # get grand mean  Z  <- sweep(eeg.data, 2, mu)     # compute average reference  Y <- matrix(numeric(nElec * nPnts), ncol = nPnts) #eeg.data                    # claim memory for output matrices  X <- Y  head.parameter <- head.parameter^2 # scaling variable defaults to 1 : [µV/m²]                                     # rescale data to head sphere if                                      # head.parameter > 1 : [µV/cm²]#
  for (e in 1:dim(G)[1]) {       # add smoothing constant (lambda) to diagonal     G[e, e] <- G[e, e] + lambda  # lambda defaults to 1*(10^-5)  }  Gi <- solve(G)               # compute G inverse  TC <- rowSums(Gi)            # compute sums for each row  sgi <- sum(TC)               # compute sum total  for (p in 1:nPnts) {    Cp <- Gi %*% Z[, p]        # compute preliminary C vector    c0 <- sum(Cp) / sgi        # common constant across electrodes    C <- Cp - (c0 * TC)        # compute final C vector    for (e in 1:nElec) {       # compute all CSDs ...      X[e, p] <- sum(C * H[e, ]) / head.parameter  # ... and scale to head size    }    if (scalp.potentials) {    # if requested, compute all SPs      for (e in 1:nElec) {         Y[e, p] <- c0 + sum(C * G[e, ])      }    }  }  if (scalp.potentials) {    interpolation <- list(csd = X, scalp.potentials = Y)     } else {    interpolation <- list(csd = X, scalp.potentials = NA)  }  return(interpolation)}
csd.data   <- CalculateCSD(eeg.data = t(NR.C66.trr), G = gh.example$G,   H = gh.example$H, lambda = 10^-5, head.parameter = 1)
csd.data$csd[1, ]
par(mfcol = c(1,2))matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", ylim = c(-20, 40))matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), lty = 1, main = "Figure 17", ylim = c(-10, 35))
par(mfcol = c(2,1))matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", ylim = c(-20, 40))matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), lty = 1, main = "Figure 17", ylim = c(-10, 35))
matplot(t(csd.data$csd), type = "l", lty = 1, main = "Figure 16", ylim = c(-20, 40))
matplot(t(csd.data$csd)[, c(14,24)], type = "l", col = c("blue", "green"), lty = 1, main = "Figure 17", ylim = c(-10, 35))
library(roxygen2)
setwd("/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox")roxygenize("/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox")
setwd("/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox")roxygenize("/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox")
setwd("/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox")roxygenize("/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox")
setwd("/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox")roxygenize("/Users/ad151/Documents/Rcode/MyPackages/csd.toolbox/package/csd.toolbox")
